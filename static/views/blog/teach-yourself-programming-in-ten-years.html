<!DOCTYPE html>
<html lang="en">
    <head>
        <!-- TODO: https://developer.mozilla.org/en-US/docs/Web/HTTP/Permissions_Policy -->
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta
            name="viewport"
            content="width=device-width, initial-scale=1.0" />
        <title>Teach Yourself Programming in Ten Years</title>
        <link
            href="https://unpkg.com/boxicons@2.1.4/css/boxicons.min.css"
            rel="stylesheet" />
        <link href="/static/styles/style.css" rel="stylesheet" />
    </head>
    <body>
        <!-- Router -->
        <header>
            <nav class="router">
                <a href="/">
                    <i class="bx bxs-user bx-md"></i>
                    <span class="text">Profile</span>
                </a>
                <a href="/static/views/links.html">
                    <i class="bx bxs-file bx-md"></i>
                    <span class="text">Articles</span>
                </a>
                <a class="theme-moon" data-theme="light">
                    <i class="bx bxs-moon bx-md"></i>
                    <span class="text">Dark</span>
                </a>
            </nav>
        </header>

        <!-- Application -->
        <main><h1 id="teach-yourself-programming-in-ten-years">Teach
Yourself Programming in Ten Years</h1>
<ul>
<li>Posted in 2022</li>
<li>Revised in 2023</li>
<li>Edited in 2024</li>
</ul>
<h2 id="introduction">Introduction</h2>
<p>Learning to program is a long, often frustrating journey, but with
persistence and the right mindset, it's achievable. Over the past
decade, I've come to understand that programming isn't just about
mastering syntax or tools—it's about developing patience,
problem-solving skills, and a solid foundation in mathematics.</p>
<p>In this article, I'll share the lessons I've learned through my
self-taught journey. Whether you're just starting or looking to improve
your skills, the insights here will help guide you in the right
direction.</p>
<h2 id="browsing-lurking-and-commiserating">Browsing, Lurking, and
Commiserating</h2>
<p>A few years ago, I stumbled upon a question in the r/learnprogramming
subreddit: <em>What can help amateur coders learn faster?</em></p>
<p>The top-voted response was simple: <em>Take your time.</em> This
advice may seem counterintuitive in an age of quick-fix solutions, but
it's a hard truth—programming is a skill that can't be rushed.</p>
<p>Another response that struck me was from /u/RonaldHarding, who
highlighted the difference between learning syntax and learning how to
solve real-world problems. Syntax can be learned relatively quickly, but
becoming a proficient programmer requires an understanding of data
structures, algorithms, networking, operating systems, and more.</p>
<p>His words resonated deeply with me because I've spent years feeling
exactly like this—like I was learning the basics but struggling to apply
them meaningfully. It was only after accepting that programming is a
long-term commitment that I started to make real progress.</p>
<h2
id="programming-is-mathematics-whether-you-like-it-or-not">Programming
is Mathematics (Whether You Like It or Not)</h2>
<p>No one told me when I started out, but programming is, at its core,
mathematics. Like many programmers, I initially dreaded math, but
eventually, I couldn't ignore its role in solving problems and writing
efficient code.</p>
<p>Computer Science is grounded in mathematical concepts—everything from
logic gates to algorithms is rooted in mathematical reasoning.
Understanding this early on can save you from frustration later. It's
not just about crunching numbers but about developing the
problem-solving mindset that math cultivates.</p>
<p>So, if you're serious about programming, you'll need to embrace math.
I won't sugarcoat it—it's a band-aid that's better ripped off quickly.
The sooner you accept this, the sooner you can start building the skills
that will make you a more effective programmer.</p>
<h3 id="persistence-is-key">Persistence is Key</h3>
<p>Programming is a marathon, not a sprint. It's easy to pick up a
language, but learning to apply it to real-world problems is where
things get tough. Like exercising a muscle, developing problem-solving
skills takes time and consistent effort.</p>
<p>You don't need a formal education to become a good programmer, but
you do need discipline. Trial and error is part of the process, and it's
how you grow. Stay with the problems longer, keep learning from your
mistakes, and you'll get there. As Einstein said: <em>“It's not that I'm
so smart; it's just that I stay with problems longer.”</em></p>
<h3 id="mathematical-foundations">Mathematical Foundations</h3>
<p>Before diving into programming, make sure you have a solid foundation
in mathematics. This will help you grasp the underlying principles
behind many programming concepts, especially as you move into more
advanced topics.</p>
<p>Here's a list of the essential math subjects that will serve you
well:</p>
<table>
<thead>
<tr class="header">
<th>Prerequisite Math</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Arithmetic</td>
</tr>
<tr class="even">
<td>Algebra</td>
</tr>
<tr class="odd">
<td>Geometry</td>
</tr>
<tr class="even">
<td>Trigonometry</td>
</tr>
<tr class="odd">
<td>Calculus</td>
</tr>
<tr class="even">
<td>Discrete Math</td>
</tr>
<tr class="odd">
<td>Statistics</td>
</tr>
<tr class="even">
<td>Linear Algebra</td>
</tr>
</tbody>
</table>
<p>Each of these subjects contributes to different aspects of
programming. For example, Algebra introduces the concept of variables
and equations, which directly translates to how we handle data in code.
Discrete Math helps with understanding algorithms and logic, while
Calculus and Linear Algebra come in handy for fields like computer
graphics or machine learning.</p>
<p>If you've already got a solid math background, you're ready to start
diving into programming. If not, consider brushing up on these subjects
to give yourself a head start.</p>
<p>Now that you've got a solid foundation in the fundamentals of
programming, the next step is choosing the right tools for the job. But
here's something that took me a while to realize: the tools you use
aren't just a matter of preference—they're shaped by the platform you're
working on. Programming languages, like the hardware and operating
systems they're built on, evolve within specific ecosystems.
Understanding the relationship between hardware, the operating system,
and the tools available is key to making smarter choices when picking
your programming language.</p>
<p>Let's break down how different platforms influence the languages you
should consider and why understanding this connection is key to working
efficiently and effectively.</p>
<h2 id="choose-a-language">Choose a Language</h2>
<p>When selecting a programming language, it's important to think beyond
just syntax or ease of learning. The real key is understanding how your
choice fits into the broader ecosystem of hardware, operating systems,
and tools.</p>
<p>Languages don't exist in a vacuum—they're shaped by the platforms
they run on. Every project has a foundation, and that foundation starts
with hardware. The hardware determines the operating system, and the
operating system dictates the available tools and languages. The
language you choose should align with the platform you're targeting,
making your work more efficient and your code more portable.</p>
<p>Let's break it down:</p>
<h3 id="hardware-the-foundation-of-everything">Hardware: The Foundation
of Everything</h3>
<p>Hardware is the base layer of any computing ecosystem. Whether it's a
CPU, GPU, or specialized hardware like ARM processors, the hardware
defines the fundamental capabilities of the system. At this level,
languages are designed to interact directly with the architecture.</p>
<ul>
<li><strong>Assembly</strong>: The lowest-level language that directly
interacts with hardware. Every processor has its own instruction set
architecture (ISA), and Assembly is the language used to work with that
ISA. It's crucial for situations where performance and direct control
over the hardware are necessary.</li>
<li><strong>C</strong>: Created at Bell Labs for building the UNIX
operating system, C is both portable and low-level enough to interact
with hardware efficiently. It abstracts away some of the complexities of
Assembly while remaining close to the machine, making it ideal for
system-level programming.</li>
</ul>
<h3 id="operating-systems-managing-hardware">Operating Systems: Managing
Hardware</h3>
<p>The operating system (OS) acts as the intermediary between the
hardware and the user space, providing the environment for applications
to run. Each OS has its own set of languages that are optimized for
interacting with its core components, both for system development and
automation through scripting.</p>
<ul>
<li><p><strong>Linux</strong>: Languages like <strong>C</strong> and
<strong>C++</strong> dominate because Linux itself is largely built with
them. These languages provide direct control over system resources like
memory, processes, and file systems, making them essential for kernel
development and system-level applications. <strong>Bash</strong> is
widely used for scripting and automating tasks within the Linux
environment.</p></li>
<li><p><strong>Windows</strong>: The <strong>.NET</strong> ecosystem is
tightly integrated with Windows, making <strong>C#</strong> a natural
choice for developing desktop applications. <strong>C++</strong> remains
important for system-level programming and game development, especially
when working with DirectX. For scripting and automation,
<strong>PowerShell</strong> is commonly used, offering a powerful
command-line toolset within Windows.</p></li>
<li><p><strong>Mac OS X</strong>: For native macOS and iOS development,
<strong>Objective-C</strong> and <strong>Swift</strong> are the key
languages. These languages are tightly integrated with Apple's
frameworks and offer the best tools for building applications within
Apple's ecosystem. <strong>Bash</strong> is also frequently used for
scripting and automating tasks within Mac OS X's UNIX-like
environment.</p></li>
</ul>
<h3 id="ecosystem-and-tooling-building-on-top-of-the-os">Ecosystem and
Tooling: Building on Top of the OS</h3>
<p>The tools you use as a programmer are defined by the combination of
hardware and operating system, forming the larger ecosystem. This
ecosystem provides the libraries, frameworks, and APIs that shape how
you build applications.</p>
<ul>
<li><strong>Web Development</strong>: The web is a unique ecosystem,
mostly independent of hardware or OS. Whether you're on Linux, Windows,
or Mac, the core languages—<strong>JavaScript</strong>,
<strong>HTML</strong>, and <strong>CSS</strong>—remain constant.
However, backend languages and tools may vary depending on your
platform. <strong>Node.js</strong>, <strong>Python</strong>, and
<strong>Ruby</strong> are popular choices in a Linux environment,
whereas <strong>ASP.NET</strong> may dominate in Windows.</li>
<li><strong>Game Development</strong>: Platforms like
<strong>Windows</strong> and <strong>consoles</strong> are often driven
by <strong>C++</strong>, as it offers the performance necessary for
graphics-intensive applications. Game engines like Unity use
<strong>C#</strong>, which integrates seamlessly with the .NET
environment on Windows, while <strong>Lua</strong> is frequently used
for scripting within engines.</li>
<li><strong>Mobile Development</strong>: For mobile platforms like iOS
and Android, the choice of language is clear-cut. <strong>Swift</strong>
and <strong>Objective-C</strong> for iOS, and <strong>Java</strong> or
<strong>Kotlin</strong> for Android, as these are the languages that
give you access to native mobile APIs provided by the OS vendors.</li>
</ul>
<h3 id="portability-making-your-code-work-across-platforms">Portability:
Making Your Code Work Across Platforms</h3>
<p>Some languages are built with portability in mind, meaning they can
be used across different platforms with minimal changes. This was one of
the reasons <strong>C</strong> became so popular—it could be compiled
and run on various hardware and operating systems without significant
rewrites. Similarly, <strong>Python</strong> is often chosen for its
ability to run on almost any platform, whether you're on Linux, Windows,
or Mac OS X.</p>
<h3 id="final-thoughts">Final Thoughts</h3>
<p>The project you're working on should always determine the tools you
use, and those tools are shaped by the ecosystem around them. By
understanding the relationship between hardware, operating systems, and
the software stack, you can make smarter choices about which language to
learn and use. Instead of focusing purely on the features of a language,
consider the platform it operates on, the problems it was designed to
solve, and how it fits into the broader ecosystem.</p>
<h3 id="learn-about-what-you-dont-know">Learn About What You Don't
Know</h3>
<p>You might feel like you've covered a lot, but there are core aspects
of programming that are often overlooked, especially if you're
self-taught. Some of the key areas you may still need to dive into
include: - <strong>Algorithms and Data Structures</strong> -
<strong>Compiler Design</strong> - <strong>Systems Design</strong> -
<strong>Design Patterns</strong> - <strong>Agile &amp; Scrum
Methodologies</strong> - <strong>Test-Driven Development (TDD)</strong>
- <strong>Behavior-Driven Development (BDD)</strong></p>
<p>These are crucial to becoming not just a coder, but a well-rounded
software engineer. You don't need to master all of them at once, but
being aware of what's out there is the first step. As the saying goes,
"You don't know what you don't know."</p>
<h3 id="tools-of-the-trade">Tools of the Trade</h3>
<p>The tools we use will always evolve, but the fundamentals rarely
change—they just get updated over time. This is where many self-taught
developers get stuck: How can you improve if you don't know what gaps
exist in your knowledge?</p>
<p>Here are a few essential resources to help you build that strong
foundation. They're just a small sample in the vast sea of knowledge out
there, but they cover critical topics that will stick with you
throughout your career:</p>
<ul>
<li><a href="https://leanpub.com/apexcalculus">Calculus</a></li>
<li><a href="https://discrete.openmathbooks.org/dmoi3.html">Discrete
Mathematics</a></li>
<li><a
href="https://stats.libretexts.org/Courses/Las_Positas_College/Math_40%3A_Statistics_and_Probability">Statistics
and Probability</a></li>
<li><a href="https://understandinglinearalgebra.org/home.html">Linear
Algebra</a></li>
<li><a href="https://www.dspguide.com/">Digital Signal
Processing</a></li>
<li><a
href="https://mitpress.mit.edu/9780262046305/introduction-to-algorithms/">Introduction
to Algorithms</a></li>
<li><a href="https://sourcemaking.com/">Design Patterns</a></li>
<li><a href="https://refactoring.guru/">Refactoring</a></li>
<li><a href="https://craftinginterpreters.com/contents.html">Crafting
Interpreters</a></li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>I've got plenty more bookmarked, so feel free to comment and ask for
more. If I can help, I will. And if I don't respond, it's probably
because I don't know the answer—hopefully someone more experienced
will.</p>
<p>Best of luck on your programming journey. Remember, it's the journey
that matters, not the destination. The destination will be a byproduct
of the effort and learning you put into the process.</p>
<h2 id="references">References</h2>
<ul>
<li><a
href="https://www.reddit.com/r/learnprogramming/comments/zpevpm/teach_yourself_programming_in_ten_years/">Original
Post</a></li>
<li><a href="https://norvig.com/21-days.html">Peter Norvig's Teach
Yourself Programming in Ten Years</a></li>
<li><a
href="https://medium.com/@andrewlatta/why-learning-to-code-is-so-damn-hard-303eae632820">Why
Learning to Code is So Damn Hard</a></li>
</ul>
<hr />
<p align="center">
Copyright (C) 2022 Austin Berrio
</p></main>

        <!-- Modules -->
        <script src="/static/modules/main.mjs" type="module"></script>
        <script type="module">
            import {Theme} from '/static/modules/main.mjs';

            const theme = new Theme();
            theme.init();
        </script>
    </body>
</html>
